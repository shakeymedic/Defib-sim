<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>ZOLL R Series Simulator - WMEBEM | RCUK 2025</title>

  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,sans-serif;background:#2a2a2a;padding:20px;min-height:100vh}
    .quick-rhythm-panel{background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);border-radius:10px;padding:20px;margin:0 auto 20px auto;max-width:1600px;border:3px solid #1a252f}
    .quick-rhythm-panel h4{color:#3498db;font-size:14px;margin-bottom:15px;text-transform:uppercase;text-align:center}
    .rhythm-buttons{display:grid;grid-template-columns:repeat(auto-fit,minmax(80px,1fr));gap:6px}
    .rhythm-btn{background:#34495e;color:#ecf0f1;border:2px solid #2c3e50;padding:8px;border-radius:6px;font-size:11px;cursor:pointer;transition:all 0.2s}
    .rhythm-btn.active{background:#2980b9;border-color:#1f5f8b}
    .main-header{display:flex;justify-content:space-between;align-items:center;max-width:1600px;margin:0 auto 20px auto;padding:10px 20px;background:linear-gradient(135deg,#2c3e50 0%,#34495e 100%);border-radius:10px;border:3px solid #1a252f}
    .menu-title h1{color:#ecf0f1;font-size:32px;margin-bottom:5px}
    .menu-title p{color:#bdc3c7}
    .zoll-device{background:#c8d0d8;border:20px solid #2b7bbf;border-radius:25px;padding:30px;box-shadow:0 20px 60px rgba(0,0,0,0.5);position:relative;display:grid;grid-template-columns:1fr;gap:20px;max-width:1400px;margin:0 auto}
    .device-screen-section{background:#a8b0b8;padding:25px;border-radius:15px;box-shadow:inset 0 4px 10px rgba(0,0,0,0.2)}
    .screen{background:#000;border-radius:10px;padding:15px;margin-bottom:15px;box-shadow:inset 0 0 20px rgba(0,0,0,0.8);position:relative}
    .screen-header{display:flex;justify-content:space-between;padding:8px;background:rgba(0,0,0,0.6);border-radius:5px;margin-bottom:10px}
    .screen-info{color:#00ffff;font-size:13px;font-family:'Courier New',monospace;text-shadow:0 0 5px rgba(0,255,255,0.5)}
    .ecg-canvas-container{background:#000;height:320px;border-radius:8px;position:relative;overflow:hidden;margin-bottom:15px}
    canvas{width:100%;height:100%;display:block}
    .vitals-display{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:15px;background:rgba(0,0,0,0.6);border-radius:8px}
    .vital-item{text-align:center}
    .vital-label{color:#888;font-size:10px;margin-bottom:5px}
    .vital-value{color:#00ff00;font-size:36px;font-weight:bold;font-family:'Courier New',monospace;text-shadow:0 0 10px rgba(0,255,0,0.6)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .control{background:#2c3e50;border:2px solid #1f2a33;border-radius:8px;color:#ecf0f1;padding:10px;display:flex;align-items:center;gap:8px}
    .control input,.control select{background:#1f2a33;color:#00ff00;border:1px solid #0f1a22;border-radius:4px;padding:6px;min-width:80px}
    .grid-layer{position:absolute;inset:0;pointer-events:none}
    .trace-layer{position:absolute;inset:0}
    @media (max-width:768px){
      body{padding:10px}
      .ecg-canvas-container{height:260px}
      .vitals-display{grid-template-columns:1fr 1fr}
      .vital-value{font-size:28px}
    }
  </style>

  <script>
(function(){
  'use strict';

  /* Units and speed */
  const PX_PER_BIG = 25;           // 5 mm big box = 25 px
  const PX_PER_MM  = PX_PER_BIG/5; // 1 mm = 5 px
  const PX_PER_MV  = PX_PER_MM*10; // 10 mm/mV
  let   ECG_SPEED  = PX_PER_BIG*5; // 25 mm/s -> 25*5 px/s = 125 px/s

  function setSpeed(pxPerSec){ ECG_SPEED = pxPerSec }

  /* Helpers and artefacts */
  const lerp=(a,b,t)=>a+(b-a)*t;
  function perlinLikeNoise(x,freq,amp){
    const a=Math.sin(x*freq*0.71)*0.5+0.5, b=Math.sin(x*freq*1.33+1.7)*0.5+0.5;
    return (a*0.6+b*0.4-0.5)*2*amp;
  }
  function movementArtefact(x,tSeconds){ return Math.sin((x+tSeconds*120)*0.05)*(PX_PER_MM*1.0) }
  function leadoffArtefact(tSeconds){ return Math.sin(tSeconds*1.2)*(PX_PER_MM*1.5) }
  function cprArtefact(x,tSeconds){
    const f=2.0;
    return Math.sin(2*Math.PI*f*tSeconds)*(PX_PER_MV*0.6)+perlinLikeNoise(x+tSeconds*60,0.03,PX_PER_MM*2.0);
  }

  /* Morphologies */
  function pWave(s,amp=0.1){ const a=Math.max(0,Math.min(1,Math.sin(Math.PI*s))); return -a*(PX_PER_MV*amp) }
  function qrsNarrow(s,rAmp=1.0,qAmp=0.15,sAmp=0.25){
    if(s<0.22){ const t=s/0.22; return PX_PER_MV*qAmp*(t*0.4) }
    else if(s<0.55){ const t=(s-0.22)/0.33; return -PX_PER_MV*rAmp*(Math.sin(t*Math.PI)) }
    else{ const t=(s-0.55)/0.45; return PX_PER_MV*sAmp*(Math.sin(t*Math.PI)) }
  }
  function qrsWide(s,rAmp=0.9){ return -PX_PER_MV*rAmp*(Math.sin(s*Math.PI)) }
  function tWave(s,amp=0.3){ return -PX_PER_MV*amp*Math.sin(s*Math.PI) }
  function pacingSpike(pxPosInCycle){ return pxPosInCycle<5 ? -PX_PER_MV*2.0 : 0 }

  /* Sinus template */
  function sinusTemplate(x,hr,canvasHeight,tSeconds,opts={}){
    const baseline=canvasHeight/2, bpm=hr>0?hr:75;
    const cyclePx=(60/bpm)*ECG_SPEED, pos=x%cyclePx, s=pos/cyclePx; let y=0;
    const pDur=0.08*ECG_SPEED/cyclePx, prEnd=pDur+0.10*ECG_SPEED/cyclePx;
    const qrsDur=0.09*ECG_SPEED/cyclePx, qrsStart=prEnd, qrsEnd=qrsStart+qrsDur;
    const tEnd=qrsEnd+0.16*ECG_SPEED/cyclePx;
    if(s<pDur){ y+=pWave(s/pDur,opts.pAmp??0.1) }
    else if(s<prEnd){ /* PR */ }
    else if(s<qrsEnd){ const q=(s-qrsStart)/(qrsDur); y+=qrsNarrow(q,opts.rAmp??1.0,opts.qAmp??0.15,opts.sAmp??0.25) }
    else if(s<tEnd){ const tp=(s-qrsEnd)/(tEnd-qrsEnd); y+=tWave(tp,opts.tAmp??0.3) }
    return baseline+y;
  }

  /* Rhythms */
  function nsr(x,hr,t,canvas){ return sinusTemplate(x,hr||75,canvas.height,t,{}) }
  function sinusBrady(x,hr,t,canvas){ return sinusTemplate(x,hr||45,canvas.height,t,{rAmp:0.9,tAmp:0.25}) }
  function sinusTach(x,hr,t,canvas){ return sinusTemplate(x,hr||120,canvas.height,t,{rAmp:1.1,tAmp:0.35}) }
  function svt(x,hr,t,canvas){
    const baseline=canvas.height/2, bpm=hr>0?hr:190;
    const cyclePx=(60/bpm)*ECG_SPEED, pos=x%cyclePx, s=pos/cyclePx; let y=0;
    const prShort=0.06*ECG_SPEED/cyclePx, qrsDur=0.08*ECG_SPEED/cyclePx;
    const qrsStart=prShort, qrsEnd=qrsStart+qrsDur, tEnd=qrsEnd+0.14*ECG_SPEED/cyclePx;
    if(s<prShort){ y+=pWave(s/prShort,0.05) }
    else if(s<qrsEnd){ y+=qrsNarrow((s-qrsStart)/qrsDur,0.95,0.1,0.2) }
    else if(s<tEnd){ y+=tWave((s-qrsEnd)/(tEnd-qrsEnd),0.25) }
    return baseline+y;
  }
  function afib(x,hr,t,canvas){
    const baseline=canvas.height/2, baseHr=hr>0?hr:140;
    const rrVar=1+perlinLikeNoise(x+t*30,0.0007,0.35);
    const bpm=Math.max(80,Math.min(190,baseHr*rrVar));
    const cyclePx=(60/bpm)*ECG_SPEED, pos=x%cyclePx, s=pos/cyclePx; let y=0;
    const qrsDur=0.09*ECG_SPEED/cyclePx, qrsEnd=qrsDur;
    if(s<qrsEnd){ y+=qrsNarrow(s/qrsDur,0.9,0.05,0.15) }
    const fBase =
      Math.sin((x*0.31)+t*7.1)*(PX_PER_MM*1.0)+
      Math.sin((x*0.52)+t*9.3)*(PX_PER_MM*0.8)+
      Math.sin((x*0.73)+t*11.7)*(PX_PER_MM*0.7)+
      Math.sin((x*1.14)+t*14.2)*(PX_PER_MM*0.5);
    return baseline+y+fBase*1.0;
  }
  function vtach(x,hr,t,canvas){
    const baseline=canvas.height/2, bpm=hr>0?hr:180;
    const cyclePx=(60/bpm)*ECG_SPEED, pos=x%cyclePx, s=pos/cyclePx; let y=0;
    const qrsDur=0.14*ECG_SPEED/cyclePx; if(s<qrsDur){ y+=qrsWide(s/qrsDur,0.9) }
    return baseline+y;
  }
  function idioventricular(x,hr,t,canvas){
    const baseline=canvas.height/2, bpm=hr>0?hr:38;
    const cyclePx=(60/bpm)*ECG_SPEED, pos=x%cyclePx, s=pos/cyclePx; let y=0;
    const qrsDur=0.16*ECG_SPEED/cyclePx; if(s<qrsDur){ y+=qrsWide(s/qrsDur,0.8) }
    return baseline+y;
  }
  function vfib(x,_hr,t,canvas){
    const baseline=canvas.height/2, coarse=PX_PER_MV*0.9, fine=PX_PER_MV*0.25;
    const k=Math.max(0,Math.min(1,t/120)), amp=lerp(coarse,fine,k);
    const y=
      Math.sin(x*0.22+t*1.1)*(amp*0.6)+
      Math.sin(x*0.33+t*1.5)*(amp*0.45)+
      Math.sin(x*0.55+t*0.9)*(amp*0.35)+
      Math.sin(x*0.88+t*1.7)*(amp*0.25)+
      Math.sin(x*1.40+t*2.2)*(amp*0.15)+
      perlinLikeNoise(x+t*30,0.02,amp*0.15);
    return baseline+y;
  }
  function chb(x,hr,t,canvas){
    const baseline=canvas.height/2, vBpm=hr>0?hr:32, pBpm=80;
    const vCycle=(60/vBpm)*ECG_SPEED, pCycle=(60/pBpm)*ECG_SPEED;
    const vPos=x%vCycle, pPos=x%pCycle; let y=0;
    const pDurPx=0.08*ECG_SPEED; if(pPos<pDurPx){ y+=pWave(pPos/pDurPx,0.12) }
    const qrsDurPx=0.16*ECG_SPEED; if(vPos<qrsDurPx){ y+=qrsWide(vPos/qrsDurPx,0.85) }
    return baseline+y;
  }

  /* FIXED paced rhythm */
  function paced(x,hr,t,canvas){
    const baseline=canvas.height/2;
    const bpmRaw = (window.state && window.state.pacerRate>0) ? window.state.pacerRate : 70;
    const safeBpm = Math.max(30, Math.min(180, bpmRaw));
    const cyclePx = (60/safeBpm)*ECG_SPEED;
    const pos = x % cyclePx; // stable, offset-free phase
    let y=0;
    y += pacingSpike(pos);
    const qrsStartPx = 3;
    const qrsDurPx   = 0.14*ECG_SPEED;
    const qrsEndPx   = qrsStartPx + qrsDurPx;
    if(pos>=qrsStartPx && pos<qrsEndPx){
      const s=(pos-qrsStartPx)/qrsDurPx; y+=qrsWide(s,0.9);
    }
    const tDurPx=0.16*ECG_SPEED, tStart=qrsEndPx, tEnd=tStart+tDurPx;
    if(pos>=tStart && pos<tEnd){ const tp=(pos-tStart)/tDurPx; y+=tWave(tp,0.25) }
    return baseline+y;
  }

  /* Other */
  function brady(x,hr,t,canvas){ return sinusTemplate(x,hr||38,canvas.height,t,{rAmp:0.9,tAmp:0.25}) }
  function asystole(x,_hr,t,canvas){
    const baseline=canvas.height/2;
    const wander=Math.sin(t*0.2)*(PX_PER_MM*0.2);
    return baseline+wander;
  }

  /* Registry */
  const rhythms = {
    nsr:(x,hr,t,cv)=>nsr(x,hr,t,cv),
    sinus_brady:(x,hr,t,cv)=>sinusBrady(x,hr,t,cv),
    sinus_tach:(x,hr,t,cv)=>sinusTach(x,hr,t,cv),
    svt:(x,hr,t,cv)=>svt(x,hr,t,cv),
    afib:(x,hr,t,cv)=>afib(x,hr,t,cv),
    vtach:(x,hr,t,cv)=>vtach(x,hr,t,cv),
    vt_pulseless:(x,hr,t,cv)=>vtach(x,180,t,cv),
    vfib:(x,hr,t,cv)=>vfib(x,hr,t,cv),
    brady:(x,hr,t,cv)=>brady(x,hr,t,cv),
    chb:(x,hr,t,cv)=>chb(x,hr,t,cv),
    paced:(x,hr,t,cv)=>paced(x,hr,t,cv),
    idioventricular:(x,hr,t,cv)=>idioventricular(x,hr,t,cv),
    asystole:(x,hr,t,cv)=>asystole(x,hr,t,cv),
    sinus:(x,hr,t,cv)=>nsr(x,hr,t,cv),
  };

  /* Grid and calibration */
  function drawECGGrid(ctx,w,h){
    ctx.save(); ctx.clearRect(0,0,w,h);
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.beginPath();
    for(let x=0;x<=w;x+=PX_PER_MM){ ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h) }
    for(let y=0;y<=h;y+=PX_PER_MM){ ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5) }
    ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=1.2; ctx.beginPath();
    for(let x=0;x<=w;x+=PX_PER_BIG){ ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h) }
    for(let y=0;y<=h;y+=PX_PER_BIG){ ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5) }
    ctx.stroke(); ctx.restore();
  }
  function drawCalibrationPulse(ctx){
    const startX=12, startY=Math.floor(ctx.canvas.height*0.75);
    const height=PX_PER_MV, width=PX_PER_BIG;
    ctx.save(); ctx.strokeStyle='#0f0'; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(startX,startY);
    ctx.lineTo(startX,startY-height);
    ctx.lineTo(startX+width,startY-height);
    ctx.lineTo(startX+width,startY);
    ctx.stroke(); ctx.restore();
  }

  /* Artefact wrapper */
  function withArtefacts(fn){
    return function(x,hr,tSeconds,canvas){
      let y = fn(x,hr,tSeconds,canvas);
      const st = window.state || {};
      const flags = (st.noise||{});
      if(flags.movement) y += movementArtefact(x,tSeconds);
      if(flags.leadoff)  y += leadoffArtefact(tSeconds);
      if(flags.cpr)      y += cprArtefact(x,tSeconds);
      return y;
    }
  }

  const wrapped = {}; Object.keys(rhythms).forEach(k=>wrapped[k]=withArtefacts(rhythms[k]));

  /* Public exports used elsewhere */
  window.rhythms = wrapped;
  window.cleanRhythms = rhythms;
  window.drawECGGrid = drawECGGrid;
  window.drawCalibrationPulse = drawCalibrationPulse;
  window.__setECGSpeed = setSpeed;
  window.pacingSpike = pacingSpike;
  window.qrsWide = qrsWide;
  window.tWave = tWave;
  window.PX_PER_MV = PX_PER_MV;

})();
  </script>

  <script>
  // Runtime: canvas setup, HiDPI, animation, UI bindings
  (function(){
    'use strict';

    const dpr = window.devicePixelRatio || 1; // HiDPI scaling
    function setupHiDPICanvas(canvas){
      const rect = canvas.getBoundingClientRect();
      canvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return ctx;
    }

    // State
    window.state = {
      rhythm: 'nsr',
      hr: 75,
      pacerRate: 70,
      noise: { movement:false, leadoff:false, cpr:false },
    };

    // DOM
    const traceCanvas = document.getElementById('ecgTrace');
    const gridCanvas  = document.getElementById('ecgGrid');
    window.__ecgCanvas = traceCanvas; // used by artefact wrapper

    let traceCtx = setupHiDPICanvas(traceCanvas);
    let gridCtx  = setupHiDPICanvas(gridCanvas);

    function redrawGrid(){
      traceCtx = setupHiDPICanvas(traceCanvas);
      gridCtx  = setupHiDPICanvas(gridCanvas);
      window.drawECGGrid(gridCtx, gridCanvas.width / (window.devicePixelRatio||1), gridCanvas.height / (window.devicePixelRatio||1));
      window.drawCalibrationPulse(gridCtx);
    }

    window.addEventListener('resize', redrawGrid, { passive:true });
    redrawGrid();

    // Rhythm buttons
    document.querySelectorAll('.rhythm-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('.rhythm-btn').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        state.rhythm = btn.dataset.rhythm;
      });
    });

    // Controls
    const hrInput = document.getElementById('hrInput');
    const pacerInput = document.getElementById('pacerInput');
    const speedSelect = document.getElementById('speedSelect');

    hrInput.addEventListener('input', ()=>{ state.hr = Math.max(20, Math.min(220, parseInt(hrInput.value||'75',10))); });
    pacerInput.addEventListener('input', ()=>{ state.pacerRate = Math.max(30, Math.min(180, parseInt(pacerInput.value||'70',10))); });

    speedSelect.addEventListener('change', ()=>{
      const mmps = parseFloat(speedSelect.value); // 10 / 25 / 50 mm/s
      const pxPerMm = (window.PX_PER_MV/10);
      const pxPerSec = pxPerMm * mmps;
      window.__setECGSpeed(pxPerSec);
    });

    // Animation
    let last = performance.now();
    let tSeconds = 0;
    let xOffsetPx = 0;

    function frame(now){
      const dt = Math.min(0.05, Math.max(0, (now - last) / 1000));
      last = now;
      tSeconds += dt;

      const mmps = parseFloat(speedSelect.value);
      const pxPerMm = (window.PX_PER_MV/10);
      const ecgSpeedPx = pxPerMm * mmps;
      xOffsetPx += ecgSpeedPx * dt;

      const w = traceCanvas.getBoundingClientRect().width;
      const h = traceCanvas.getBoundingClientRect().height;

      traceCtx.clearRect(0,0,w,h);

      const rhythmName = state.rhythm;
      const renderer = window.rhythms[rhythmName] || window.rhythms.nsr;

      traceCtx.save();
      traceCtx.strokeStyle = '#0f0';
      traceCtx.lineWidth = 2;
      traceCtx.beginPath();

      for(let sx=0; sx<w; sx++){
        const worldX = sx + xOffsetPx;
        const y = renderer(worldX, state.hr, tSeconds, traceCanvas);
        if(sx===0) traceCtx.moveTo(0, y);
        else traceCtx.lineTo(sx, y);
      }

      traceCtx.stroke();
      traceCtx.restore();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  })();
  </script>
</head>

<body>
  <div class="main-header">
    <div style="display:flex;align-items:center;gap:20px;">
      <img src="images/logo.png" alt="WMEBEM Logo" style="height:60px;background:white;padding:10px;border-radius:10px;">
      <div class="menu-title" style="margin-bottom:0;text-align:left;">
        <h1>ZOLL R Series Simulator</h1>
        <p>RCUK 2025 Guidelines Simulator</p>
      </div>
    </div>
    <div class="controls">
      <div class="control">
        <label for="hrInput">HR (bpm)</label>
        <input id="hrInput" type="number" value="75" min="20" max="220"/>
      </div>
      <div class="control">
        <label for="pacerInput">Pacer (bpm)</label>
        <input id="pacerInput" type="number" value="70" min="30" max="180"/>
      </div>
      <div class="control">
        <label for="speedSelect">Speed</label>
        <select id="speedSelect">
          <option value="10">10 mm/s</option>
          <option value="25" selected>25 mm/s</option>
          <option value="50">50 mm/s</option>
        </select>
      </div>
    </div>
  </div>

  <div class="quick-rhythm-panel">
    <h4>Quick Rhythm Select</h4>
    <div class="rhythm-buttons">
      <button class="rhythm-btn active" data-rhythm="nsr">NSR</button>
      <button class="rhythm-btn" data-rhythm="vfib">VF</button>
      <button class="rhythm-btn" data-rhythm="vt_pulseless">VT (Pulseless)</button>
      <button class="rhythm-btn" data-rhythm="vtach">VT (Pulsed)</button>
      <button class="rhythm-btn" data-rhythm="svt">SVT</button>
      <button class="rhythm-btn" data-rhythm="afib">AF</button>
      <button class="rhythm-btn" data-rhythm="sinus_brady">SB</button>
      <button class="rhythm-btn" data-rhythm="sinus_tach">ST</button>
      <button class="rhythm-btn" data-rhythm="asystole">ASY</button>
      <button class="rhythm-btn" data-rhythm="chb">CHB</button>
      <button class="rhythm-btn" data-rhythm="paced">PACED</button>
      <button class="rhythm-btn" data-rhythm="idioventricular">IVR</button>
    </div>
  </div>

  <div class="zoll-device">
    <div class="device-screen-section">
      <div class="screen">
        <div class="screen-header">
          <div class="screen-info">Lead II</div>
          <div class="screen-info">Speed: <span id="speedLabel">25 mm/s</span></div>
        </div>
        <div class="ecg-canvas-container">
          <canvas id="ecgGrid" class="grid-layer"></canvas>
          <canvas id="ecgTrace" class="trace-layer"></canvas>
        </div>
        <div class="vitals-display">
          <div class="vital-item">
            <div class="vital-label">HR</div>
            <div class="vital-value" id="hrDisplay">--</div>
            <div class="vital-unit">bpm</div>
          </div>
          <div class="vital-item">
            <div class="vital-label">SpO2</div>
            <div class="vital-value">--</div>
            <div class="vital-unit">%</div>
          </div>
          <div class="vital-item">
            <div class="vital-label">EtCO2</div>
            <div class="vital-value">--</div>
            <div class="vital-unit">mmHg</div>
          </div>
          <div class="vital-item">
            <div class="vital-label">BP</div>
            <div class="vital-value" id="bpDisplay">--/--</div>
            <div class="vital-unit">mmHg</div>
          </div>
        </div>
      </div>
      <div class="controls" style="margin-top:10px;">
        <div class="control">
          <label><input type="checkbox" id="noiseMove"> Movement</label>
        </div>
        <div class="control">
          <label><input type="checkbox" id="noiseLead"> Lead-off</label>
        </div>
        <div class="control">
          <label><input type="checkbox" id="noiseCPR"> CPR</label>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Simple UI updates for displays
    (function(){
      const hrIn = document.getElementById('hrInput');
      const pacerIn = document.getElementById('pacerInput');
      const speedSel = document.getElementById('speedSelect');
      const hrDisp = document.getElementById('hrDisplay');
      const speedLabel = document.getElementById('speedLabel');
      const noiseMove = document.getElementById('noiseMove');
      const noiseLead = document.getElementById('noiseLead');
      const noiseCPR  = document.getElementById('noiseCPR');

      function update(){
        hrDisp.textContent = String(window.state.hr||'--');
        speedLabel.textContent = `${speedSel.value} mm/s`;
        window.state.noise.movement = !!noiseMove.checked;
        window.state.noise.leadoff  = !!noiseLead.checked;
        window.state.noise.cpr      = !!noiseCPR.checked;
      }
      ['input','change'].forEach(ev=>{
        hrIn.addEventListener(ev, update);
        pacerIn.addEventListener(ev, update);
        speedSel.addEventListener(ev, update);
        noiseMove.addEventListener(ev, update);
        noiseLead.addEventListener(ev, update);
        noiseCPR.addEventListener(ev, update);
      });
      update();
    })();
  </script>
</body>
</html>